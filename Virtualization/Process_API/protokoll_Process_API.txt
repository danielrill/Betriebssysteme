################################################################################

p1.c

PID = process identifier
pid_t 		getpid(void)		<unistd.h>

In UNIX-systemen wird der PID genutzt um einem Prozess einen Namen zu geben, um diesen ggf. zu stoppen.

Wird in einem Programm der SysCall fork() aufgerufen so wird der gerade laufende Prozess (beinahe) exakt kopiert und
ein resultierender 'kind-Prozess' erzeugt. Der Kind-Prozess hat eine _eigene_ Kopie des 
Adressraums/address space ( einen eigenen SpeicherPlatz ), eigene Register, einen eigenen PC usw.  ,
der zurückgegebene Wert bei einem fork()-Aufruf ist anderst. Genauer betrachtet: Der Eltern-Prozess erhält den PID
des neu erzeugten Kindes, das Kind jedoch erhält einen _return code of zero_ (?)

Dies ist nützlich, da es dann einfacher ist Code zuschreiben welcher beide Fälle behandelt.

Der Output von p1.c ist _nicht Deterministisch_ wird ein Kind-Prozess erzeugt laufen zwei aktive Prozesse
Bei einem Einkern-Prozessor läuft zu einem ZeitPunkt entweder der Eltern- oder der Kind-Prozess zuerst.

1-	./p1
	hello world (pid:5323) 
	Hello, i am a parent of 5324 (pid:5323) 

2-	Hello, i am a child (pid:5324)

Es Kann aber sehr Wohl in umgekehrte Reihenfolge stattfinden: ( wait()-Aufruf )

1-	./p2
	hello world (pid:5952) 
	Hello, i am a child (pid:5953)

	Hello, i am a parent of 5953 (rc_wait:5953) (:5952)
	
p2.c
#	int rc_wait = wait(NULL);	// parent process will wait until the child has been executed
#	printf("\nHello, i am a parent of %d (rc_wait:%d) (:%d) \n", rc ,rc_wait ,(int) getpid());

Dieses Verhalten wird vom CPU SCHEDULER (später) verursacht, dieser bestimmt welcher Prozess zu welcher Zeit
zulaufen hat.

Dies führt zu interessanten Problemstellungen in multi-threaded programs (TEIL 2)

################################################################################

Warum ?
Wie sich herausstellt ist die Unterteilung in fork() und exec() von bedeutung beim Bau einer UNIX SHELL, weil es der 
Shell erlaubt Code auszuführen nachdem fork() aufgerufen wurde, jedoch _vor_ dem exec() Aufruf.
Dieser Code erlaubt es, die Umgebung des in kürze auszuführenden Programmes zu beeinflussen und daher eine Vielzahl
interessanter Eigenschaften zum Aufbau bereitzustellen .

TIP: Getting It Right 	( Lampson's Law )
The combination of fork() and exec() are simple and immensely powerful. Here, the UNIX designers simply got it right.

################################################################################
Shell
Die Shell ist einfach ein Nutzer-Programm, es gibt davon sehr viele.

Bourne shell		|		/bin/sh
Bourne again shell	|		/bin/bash
C shell				|		/bin/csh
Z shell				|		/bin/zsh
Korn shell			|		/bin/ksh
Tennex c shell		|		/bin/tcsh

( Man sollte mind.1 wählen und erlernen (Man-Pages) alle UNIX-Experten machen das )

Eine Shell zeigt ein _prompt_ und wartet das man damit was anstellt. ( Kommando-eingeben, Programm und Argumente...)
In den meisten Fällen:
Lokalisiert das auszuführende Programm im Verzeichnissystem 
ruft fork() auf um einen neuen Kind-Prozess zu erzeugen um das Kommando auszuführen.
ruft exec() (eine Variante davon) auf um das Kommando auszuführen, und wartet bis das Kommando ausgeführt wurde 
mit wait(), sobald der Kind-Prozess komplett ausgeführt wurde, verlässt die shell den wait() -Zustand und wartet auf den 
nächsten Befehl.

// Seite 42 mitte.




